---------------------------------------------------------------------------------------------------
-- ADJACENT 2-MINOR IDEALS OF COLLECTIONS OF CELLS
---------------------------------------------------------------------------------------------------
--
-- Adjacent 2-minor ideals were first introduced by JÃ¼rgen Herzog and Takayuki Hibi in the paper 
-- "Ideals generated by adjacent 2-minors", published in the Journal of Commutative Algebra.  
--
-- Roughly speaking, if P is a collection of cells, the adjacent 2-minor ideal of P is generated
-- by the 2-minors associated with the cells of P.
--
-- In these functions, a collection of cells is encoded as a list Q whose elements are the cells.
-- Each cell is represented by a list containing its diagonal corners.
--
-- For instance, the collection of cells
--
--              __
--           __|__|__
--          |__|  |__|      
--
-- is encoded as Q={{{1,1},{2,2}},{{2,2},{3,3}},{{3,1},{4,2}}}.
--
-- Then the adjacent 2-minor ideal of P is generated by
--   x_(1,1)x_(2,2) - x_(1,2)x_(2,1),
--   x_(2,2)x_(3,3) - x_(2,3)x_(3,2),
--   x_(3,1)x_(4,2) - x_(3,2)x_(4,1).
--
-- This Macaulay2 script is intended to investigate the radicality of this class of binomial ideals. 
-- The implementation is organized in two main parts:
--   1. Construction of the adjacent 2-minor ideal of a collection of cells.
--   2. Testing radicality of such ideals (using either standard radical or binomialRadical).
--
-- Important prerequisites:
--   * The Macaulay2 package "Binomials" is required for the function TestBinomialRadicality.
---------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------
-- FUNCTION: AdjIdeal(Q)
-- INPUT:  Q, a list encoding a collection of cells.
-- OUTPUT: The ideal generated by the adjacent 2-minors of Q.
--
-- This function constructs the adjacent 2-minor ideal of a given collection of cells.
--------------------------------------------------------------------------------------------------- 
AdjIdeal = (Q) -> (
    Vertices = {};
    for cell in Q do (
        Vertices = join(Vertices, {cell_0, cell_0+{1,0}, cell_0+{1,1}, cell_0+{0,1}});
    );
    Vertices = toList(set(Vertices));
    VerticesAsPair = apply(Vertices, i -> toSequence(i));        
    listOfVar = apply(VerticesAsPair, i -> x_i);                
    AdjRing = QQ[listOfVar, MonomialOrder => Lex];

    GensForIdeal = {};
    for cell in Q do (
        lowerLeftCorner  = toSequence(cell_0);
        upperRightCorner = toSequence(cell_0+{1,1});
        upperLeftCorner  = toSequence(cell_0+{0,1});
        lowerRightCorner = toSequence(cell_0+{1,0});
        gen = x_lowerLeftCorner*x_upperRightCorner-x_upperLeftCorner*x_lowerRightCorner;
        GensForIdeal = join(GensForIdeal, {gen});
    );
    return ideal(GensForIdeal);   
);


---------------------------------------------------------------------------------------------------
-- FUNCTION: TestRadicality(L)
-- INPUT:  L, a list of collections of cells.
-- OUTPUT: The list of collections in L whose adjacent 2-minor ideal is NOT radical.
--
-- This function tests radicality using the standard radical() command from Macaulay2.
-- It prints progress every 100 iterations and saves the non-radical collections to a text file.
---------------------------------------------------------------------------------------------------
TestRadicality = (L) -> (
    numberCollections := #L;
    numberGenerators := #(L#0);
    CollectionList = {};
    for i from 0 to #L-1 do (
        if i % 100 == 0 then print("Iteration " | toString(i+1) | " of " | toString(numberCollections));
        I = AdjIdeal(L#i);
        if radical I != I then CollectionList = append(CollectionList, L#i);
    );
    fileName = "NoRadical_" | toString(numberGenerators) | ".txt";
    fileName << CollectionList << endl << close;
    print("Number of NON-radical collections of cells: " | toString(#CollectionList) | " over " | toString(numberCollections));
    return netList CollectionList;
);


---------------------------------------------------------------------------------------------------
-- FUNCTION: TestBinomialRadicality(L)
-- INPUT:  L, a list of collections of cells.
-- OUTPUT: The list of collections in L whose adjacent 2-minor ideal is NOT radical.
--
-- This function tests radicality using the binomialRadical() command 
-- from the package "Binomials". It works similarly to TestRadicality, 
-- but is specific to binomial ideals.
---------------------------------------------------------------------------------------------------
TestBinomialRadicality = (L) -> (
    numberCollections := #L;
    numberGenerators := #(L#0);
    CollectionList = {};
    for i from 0 to #L-1 do (
        if i % 100 == 0 then print("Iteration " | toString(i+1) | " of " | toString(numberCollections));
        I = AdjIdeal(L#i);
        if binomialRadical I != I then CollectionList = append(CollectionList, L#i);
    );
    fileName = "NoRadical_" | toString(numberGenerators) | ".txt";
    fileName << CollectionList << endl << close;
    print("Number of NON-radical collections of cells: " | toString(#CollectionList) | " over " | toString(numberCollections));
    return netList CollectionList;
);


---------------------------------------------------------------------------------------------------
-- EXAMPLE OF USE
--
-- L = value get("weak_polyplets_n8.txt");
-- time TestBinomialRadicality(L);
---------------------------------------------------------------------------------------------------
